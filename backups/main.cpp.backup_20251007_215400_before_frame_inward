/*
 * ST7735 Bitmap Display Receiver - DueLCD01 Configuration
 * Arduino Due program to receive bitmap data from Raspberry Pi via serial
 * and display on ST7735 LCD (160x128 pixels)
 * 
 * Based on calibration findings: 
 * - Usable origin: (1, 2)
 * - Usable size: 158 x 126 pixels
 * - White frame and origin-to-center line shown while waiting
 * 
 * Wiring for ST7735 to Arduino Due (DueLCD01):
 * VCC -> 3.3V
 * GND -> GND
 * CS  -> Pin 7
 * RST -> Pin 8  
 * DC  -> Pin 10
 * SDA -> Pin 11 (MOSI)
 * SCK -> Pin 13 (SCK)
 * BL  -> Pin 9 (backlight)
 */

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <SPI.h>

// Display 1 pin definitions (Bitmap Display)
#define TFT1_CS     7      // Chip Select
#define TFT1_DC     10     // Data/Command select
#define TFT1_RST    8      // Reset
#define TFT1_BL     9      // Backlight control

// Display 2 pin definitions (Clock Display)
#define TFT2_CS     29     // Chip Select
#define TFT2_DC     31     // Data/Command select
#define TFT2_RST    33     // Reset
#define TFT2_BL     35     // Backlight control

// Display dimensions (based on calibration findings)
#define DISPLAY_WIDTH  160
#define DISPLAY_HEIGHT 128
#define USABLE_ORIGIN_X 1    // Calibrated usable origin X
#define USABLE_ORIGIN_Y 2    // Calibrated usable origin Y  
#define USABLE_WIDTH   158   // Calibrated usable width
#define USABLE_HEIGHT  126   // Calibrated usable height

// Create ST7735 instances
Adafruit_ST7735 tft1 = Adafruit_ST7735(TFT1_CS, TFT1_DC, TFT1_RST);  // Display 1 - Bitmap
Adafruit_ST7735 tft2 = Adafruit_ST7735(TFT2_CS, TFT2_DC, TFT2_RST);  // Display 2 - Clock

// Bitmap reception state
enum BitmapState {
  WAITING_FOR_START,
  WAITING_FOR_SIZE,
  RECEIVING_DATA,
  WAITING_FOR_END,
  BITMAP_COMPLETE
};

// Global variables
BitmapState currentState = WAITING_FOR_START;
int bitmapWidth = 0;
int bitmapHeight = 0;
int currentRow = 0;
int currentCol = 0;
int offsetX = 0;  // X offset to center bitmap
int offsetY = 0;  // Y offset to center bitmap
unsigned long lastActivity = 0;
const unsigned long TIMEOUT_MS = 15000; // 15 second timeout for data reception

// Function prototypes
void drawWaitingDisplay();
void displayError(const String& errorMsg);
void displaySuccess();
bool validateDimensions(int width, int height);
bool isWithinBounds(int x, int y);
bool calculateOffsets(int bmpWidth, int bmpHeight, int& offsetX, int& offsetY);
void processSerialData();
void checkTimeout();

void setup() {
  // Initialize serial communication
  Serial.begin(115200);
  while (!Serial) {
    ; // Wait for serial port to connect
  }
  
  // Enable Port C for extended pins (29, 31, 33, 35)
  pmc_enable_periph_clk(ID_PIOC);
  
  // Initialize Display 1 backlight control
  pinMode(TFT1_BL, OUTPUT);
  digitalWrite(TFT1_BL, HIGH);  // Turn on backlight
  
  // Initialize Display 2 backlight control
  pinMode(TFT2_BL, OUTPUT);
  digitalWrite(TFT2_BL, HIGH);  // Turn on backlight
  
  // Initialize SPI
  SPI.begin();
  
  // Initialize Display 1 (Bitmap Display) - Landscape mode
  tft1.initR(INITR_BLACKTAB);   // Initialize ST7735S chip, black tab
  tft1.setRotation(1);          // Landscape mode
  tft1.fillScreen(ST77XX_BLACK); // Explicit black fill for clean initialization
  drawWaitingDisplay();
  
  // Initialize Display 2 (Clock Display) - Portrait mode with frame
  tft2.initR(INITR_BLACKTAB);   // Initialize ST7735S chip, black tab
  tft2.setRotation(0);          // Portrait mode
  tft2.fillScreen(ST77XX_BLACK); // Explicit black fill for clean initialization
  
  // Draw frame moved 2 pixels right and 1 pixel down with thicker right and bottom
  tft2.drawRect(2, 1, 128, 160, ST77XX_WHITE);
  tft2.drawRect(3, 2, 126, 158, ST77XX_WHITE);
  
  // Add extra thickness to right and bottom edges (1 pixel thicker)
  tft2.drawLine(130, 1, 130, 161, ST77XX_WHITE);  // Right edge +1 pixel
  tft2.drawLine(131, 2, 131, 160, ST77XX_WHITE);  // Right edge inner +1 pixel
  tft2.drawLine(2, 161, 131, 161, ST77XX_WHITE);  // Bottom edge +1 pixel  
  tft2.drawLine(3, 160, 130, 160, ST77XX_WHITE);  // Bottom edge inner +1 pixel
  
  Serial.println("Dual ST7735 Display System Initialized");
  Serial.println("Display 1: Bitmap receiver (" + String(USABLE_WIDTH) + "x" + String(USABLE_HEIGHT) + " usable)");
  Serial.println("Display 2: Frame and test pattern in portrait mode");
  Serial.println("Ready to receive bitmap data");
  Serial.println("Waiting for connection...");
  
  lastActivity = millis();
}

void drawWaitingDisplay() {
  // Clear screen
  tft1.fillScreen(ST77XX_BLACK);
  
  // Draw white frame using calibrated usable area
  tft1.drawRect(USABLE_ORIGIN_X, USABLE_ORIGIN_Y, USABLE_WIDTH, USABLE_HEIGHT, ST77XX_WHITE);
  
  // Draw line from origin to usable center
  int centerX = USABLE_ORIGIN_X + USABLE_WIDTH / 2;
  int centerY = USABLE_ORIGIN_Y + USABLE_HEIGHT / 2;
  
  // Draw diagonal line from actual origin (0,0) to usable center
  tft1.drawLine(0, 0, centerX, centerY, ST77XX_YELLOW);
  
  // Mark origin with white pixels
  tft1.drawPixel(0, 0, ST77XX_WHITE);
  tft1.drawPixel(1, 0, ST77XX_WHITE);
  tft1.drawPixel(0, 1, ST77XX_WHITE);
  
  // Mark usable center with red cross
  tft1.drawPixel(centerX, centerY, ST77XX_RED);
  tft1.drawPixel(centerX-1, centerY, ST77XX_RED);
  tft1.drawPixel(centerX+1, centerY, ST77XX_RED);
  tft1.drawPixel(centerX, centerY-1, ST77XX_RED);
  tft1.drawPixel(centerX, centerY+1, ST77XX_RED);
}

void displayError(const String& errorMsg) {
  Serial.println("ERROR: " + errorMsg);
  
  // Display error on screen
  tft1.fillScreen(ST77XX_RED);
  tft1.setTextColor(ST77XX_WHITE);
  tft1.setTextSize(1);
  tft1.setCursor(5, 10);
  tft1.println("ERROR:");
  tft1.setCursor(5, 25);
  tft1.println(errorMsg);
  
  // Reset state
  currentState = WAITING_FOR_START;
  bitmapWidth = 0;
  bitmapHeight = 0;
  currentRow = 0;
  currentCol = 0;
  offsetX = 0;
  offsetY = 0;
}

void displaySuccess() {
  Serial.println("COMPLETE");
  Serial.println("Bitmap display completed successfully!");
  
  // Redraw the white frame around the usable area after bitmap display
  tft1.drawRect(USABLE_ORIGIN_X, USABLE_ORIGIN_Y, USABLE_WIDTH, USABLE_HEIGHT, ST77XX_WHITE);
}

bool validateDimensions(int width, int height) {
  // Check for negative or zero dimensions
  if (width <= 0 || height <= 0) {
    displayError("Invalid dimensions: width=" + String(width) + ", height=" + String(height));
    return false;
  }
  
  // Check for unreasonably large dimensions (prevent overflow)
  if (width > 1000 || height > 1000) {
    displayError("Dimensions too large: width=" + String(width) + ", height=" + String(height));
    return false;
  }
  
  // Check if bitmap fits within usable area
  if (width > USABLE_WIDTH) {
    displayError("Width " + String(width) + " exceeds usable width " + String(USABLE_WIDTH));
    return false;
  }
  
  if (height > USABLE_HEIGHT) {
    displayError("Height " + String(height) + " exceeds usable height " + String(USABLE_HEIGHT));
    return false;
  }
  
  Serial.println("Dimensions validated: " + String(width) + "x" + String(height));
  return true;
}

bool isWithinBounds(int x, int y) {
  return (x >= USABLE_ORIGIN_X && 
          x < USABLE_ORIGIN_X + USABLE_WIDTH && 
          y >= USABLE_ORIGIN_Y && 
          y < USABLE_ORIGIN_Y + USABLE_HEIGHT &&
          x >= 0 && x < tft1.width() &&
          y >= 0 && y < tft1.height());
}

bool calculateOffsets(int bmpWidth, int bmpHeight, int& offsetX, int& offsetY) {
  // Calculate centering offsets within usable area
  int usableCenterX = USABLE_ORIGIN_X + USABLE_WIDTH / 2;
  int usableCenterY = USABLE_ORIGIN_Y + USABLE_HEIGHT / 2;
  int bitmapCenterX = bmpWidth / 2;
  int bitmapCenterY = bmpHeight / 2;
  
  offsetX = usableCenterX - bitmapCenterX;
  offsetY = usableCenterY - bitmapCenterY;
  
  // Verify the bitmap will fit with calculated offsets
  int minX = offsetX;
  int maxX = offsetX + bmpWidth - 1;
  int minY = offsetY;
  int maxY = offsetY + bmpHeight - 1;
  
  if (!isWithinBounds(minX, minY) || !isWithinBounds(maxX, maxY)) {
    displayError("Calculated bitmap position exceeds bounds");
    Serial.println("Bitmap bounds: (" + String(minX) + "," + String(minY) + ") to (" + String(maxX) + "," + String(maxY) + ")");
    Serial.println("Usable bounds: (" + String(USABLE_ORIGIN_X) + "," + String(USABLE_ORIGIN_Y) + ") to (" + String(USABLE_ORIGIN_X + USABLE_WIDTH - 1) + "," + String(USABLE_ORIGIN_Y + USABLE_HEIGHT - 1) + ")");
    return false;
  }
  
  Serial.println("Usable center: (" + String(usableCenterX) + ", " + String(usableCenterY) + ")");
  Serial.println("Bitmap center: (" + String(bitmapCenterX) + ", " + String(bitmapCenterY) + ")");
  Serial.println("Centering at offset: (" + String(offsetX) + ", " + String(offsetY) + ")");
  Serial.println("Bitmap will occupy: (" + String(minX) + "," + String(minY) + ") to (" + String(maxX) + "," + String(maxY) + ")");
  
  return true;
}

void processSerialData() {
  if (Serial.available()) {
    lastActivity = millis();
    
    switch (currentState) {
      case WAITING_FOR_START: {
        String command = Serial.readStringUntil('\n');
        command.trim();
        
        if (command == "BMPStart") {
          Serial.println("Start marker received");
          currentState = WAITING_FOR_SIZE;
        }
        break;
      }
      
      case WAITING_FOR_SIZE: {
        String sizeCommand = Serial.readStringUntil('\n');
        sizeCommand.trim();
        
        if (sizeCommand.startsWith("SIZE:")) {
          // Parse dimensions: SIZE:width,height
          int commaIndex = sizeCommand.indexOf(',');
          if (commaIndex > 0) {
            bitmapWidth = sizeCommand.substring(5, commaIndex).toInt();
            bitmapHeight = sizeCommand.substring(commaIndex + 1).toInt();
            
            if (validateDimensions(bitmapWidth, bitmapHeight) && 
                calculateOffsets(bitmapWidth, bitmapHeight, offsetX, offsetY)) {
              
              Serial.println("READY");
              Serial.println("Receiving bitmap: " + String(bitmapWidth) + "x" + String(bitmapHeight));
              
              // Clear display and redraw frame for centering reference
              tft1.fillScreen(ST77XX_BLACK);
              tft1.drawRect(USABLE_ORIGIN_X, USABLE_ORIGIN_Y, USABLE_WIDTH, USABLE_HEIGHT, ST77XX_WHITE);
              
              // Initialize bitmap position with bounds checking
              currentRow = 0;
              currentCol = 0;
              
              // Verify we're ready to receive data
              if (bitmapWidth > 0 && bitmapHeight > 0) {
                currentState = RECEIVING_DATA;
                Serial.println("Ready to receive " + String(bitmapWidth * bitmapHeight) + " pixels");
              } else {
                displayError("Invalid bitmap dimensions after validation");
              }
            }
          } else {
            displayError("Invalid size format");
          }
        }
        break;
      }
      
      case RECEIVING_DATA: {
        // Read pixel data (2 bytes per pixel for RGB565)
        while (Serial.available() >= 2 && currentState == RECEIVING_DATA) {
          if (currentRow >= bitmapHeight) {
            // All pixels received, wait for end marker
            currentState = WAITING_FOR_END;
            break;
          }
          
          // Read RGB565 pixel data (big-endian)
          uint8_t highByte = Serial.read();
          uint8_t lowByte = Serial.read();
          uint16_t pixelColor = (highByte << 8) | lowByte;
          
          // Calculate pixel position with bounds checking
          int displayX = currentCol + offsetX;
          int displayY = currentRow + offsetY;
          
          // Comprehensive bounds checking before drawing
          if (isWithinBounds(displayX, displayY)) {
            tft1.drawPixel(displayX, displayY, pixelColor);
          } else {
            // Log out-of-bounds attempts (but don't error - might be expected)
            static unsigned long lastWarning = 0;
            unsigned long now = millis();
            if (now - lastWarning > 1000) { // Limit warnings to once per second
              Serial.println("Warning: Pixel at (" + String(displayX) + "," + String(displayY) + ") out of bounds");
              lastWarning = now;
            }
          }
          
          // Advance to next pixel with bounds checking
          currentCol++;
          if (currentCol >= bitmapWidth) {
            currentCol = 0;
            currentRow++;
            
            // Bounds check for row overflow
            if (currentRow > bitmapHeight) {
              Serial.println("Error: Row overflow detected");
              currentState = WAITING_FOR_END;
              break;
            }
            
            // Progress indication every 10 rows
            if (currentRow % 10 == 0 && currentRow < bitmapHeight) {
              float progress = (float)currentRow / bitmapHeight * 100;
              Serial.println("Progress: " + String(progress, 1) + "% (Row " + String(currentRow) + "/" + String(bitmapHeight) + ")");
            }
          }
          
          // Additional safety check for column bounds
          if (currentCol < 0 || currentCol > bitmapWidth) {
            Serial.println("Error: Column bounds violation");
            currentCol = 0;
          }
        }
        break;
      }
      
      case WAITING_FOR_END: {
        String endCommand = Serial.readStringUntil('\n');
        endCommand.trim();
        
        if (endCommand == "BMPEnd") {
          currentState = BITMAP_COMPLETE;
          displaySuccess();
        }
        break;
      }
      
      case BITMAP_COMPLETE: {
        // Ready for next bitmap
        currentState = WAITING_FOR_START;
        bitmapWidth = 0;
        bitmapHeight = 0;
        currentRow = 0;
        currentCol = 0;
        offsetX = 0;
        offsetY = 0;
        Serial.println("Ready for next bitmap");
        break;
      }
    }
  }
}

void checkTimeout() {
  if (currentState != WAITING_FOR_START && currentState != BITMAP_COMPLETE && (millis() - lastActivity > TIMEOUT_MS)) {
    displayError("Timeout waiting for data");
    Serial.println("Timeout - resetting to wait for new bitmap");
  }
}

void loop() {
  processSerialData();
  checkTimeout();
  
  // Small delay to prevent overwhelming the processor
  delay(1);
}